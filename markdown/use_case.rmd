---
title: "rANOMALY step-by-step use case."
author: "Etienne Rifa & Sebastien Theil"
date: "17/08/2020"
output:
  html_document:
    toc: yes
    toc_float: yes
    collapsed: no
    smooth_scroll: no
    number_sections: yes
    code_folding: show
  pdf_document:
    toc: yes
fig_width: 15
---


```{r loading_libraries, warning = FALSE, message=FALSE, include=FALSE, results='hide'}
library(DT)
library(pander)
devtools::load_all(".")
```
We share this use case to show all features of rANOMALY packages that allow to highlight difference of microbial community between groups of samples. rANOMALY main features are :

* ASV generation thanks to `dada2` algorithm

* Taxonomic assignment thanks to IDTAXA from `DECIPHER` packages. rANOMALY allow to assign with up to 2 complementary reference database (eg. SILVA which generalist, DAIRYdb which is specific to dairy environments), keep the best and more confident taxonomic assignment, check for taxonomy incongruency like empty fields and multiple ancestors.

* Phyloseq format to handle datas and downstream statistical analysis.

* Decontamination step thanks to `decontam` package. rANOMALY allows to filter ASV (Amplicon Sequence Variant) dependings on ASV overall frequence (low abondance filter), and ASV prevalence (presence in 1 or more samples), specific filters like manual suppression of specific taxa are available to.

* Complete statistical analysis workflow: rarefaction curves, community composition plots, alpha/beta diversity analysis with associated statistical tests and multivariate analysis, and differential analysis using 3 three different methods (metacoder, DESeq2, metagenomeSeq).

* At each steps plots and R objects are saved in folders to be able to relaunch the analysis and to exports plots.


# Help

Each function has a detailed help accessible in R via `?{function}`.

# Tests datasets

The dataset can be downloaded via this [link](https://nextcloud.inrae.fr/s/Zx3iASe64x8oSoM).

This tutorial assume that you have extracted all the read file in a folder named `reads` along with the `sample-metadata.csv` file.

We share a 24 samples test dataset extract from rats feces at two different time (t0 & t50) and in two nutrition conditions. Rats were feeded with to strain of a particular bacteria (wild type & mutant). Also, extraction control sample (blank) included two are included.

```{r loading_metadata, warning = FALSE, message = TRUE}
sm <- read.table("sample_metadata.csv", sep="\t",header=TRUE)
DT::datatable(sm)
```

```{r}
load("decontam_out/robjects.Rdata")
```

# Processing of raw sequences

## ASV definition with DADA2

The first step will be the creation of ASVs thanks to the dada2 package.
In rANOMALY, only one function is needed to compute all the different steps require from this package.

Sample names will be extracted from the file name, from the begining to the first underscore (_), so files must be formatted as followed :
{sample-id1}_R1.fastq.gz
{sample-id1}_R2.fastq.gz
etc...
Those must match the sample name that are stored in the sample metadata file.

```{r eval=FALSE}
dada_res = dada2_fun(path="./reads", dadapool = "pseudo", compress=TRUE, plot=FALSE)
```

Main outputs:

* `./dada2_out/read_tracking.csv` summarize the read number after each filtering step.

* `./dada2_out/raw_otu-table.csv` the raw ASV table

* `./dada2_out/rep-seqs.fna`: fasta file with all representative sequences for each ASV

* `./dada2_out/robjects.Rdata` with saved dada_res list containing raw ASV table and representative sequences in objects `otu.table`, `seqtab.export` & `seqtab.nochim`.


Read tracking table:

* *input*: raw read number.

* *filtered*: after dada2 filtering step: no N's in sequence, low quality, and phiX.

* *denoisedF* & *denoisedR*: after denoising. Forward & Reverse.

* *merged*: after merging R1 & R2.

* *nonchim*: after chimeras filtering.

```{r}
DT::datatable(read.table("dada2_out/read_tracking.csv",sep="\t",header=TRUE), filter = "top")
```

## Taxonomic assignment

`assign_taxo_fun` function uses IDTAXA function from DECIPHER package, and allows to use 2 differents databases. It keeps the best assignment on 2 criteria, resolution (depth) and confidence. The final taxonomy is validated by multiple ancestors taxa and incongruity correction step.

We share the latest databases we use in the IDTAXA format in this [link](https://nextcloud.inrae.fr/s/YHi3fmDdEJt5cqR). You can also generate your own IDTAXA formatted database following those instructions and scripts we provide at  [this page](https://forgemia.inra.fr/umrf/ranomaly/-/wikis/idtaxa_db_proc).


```{r eval=FALSE}
tax.table = assign_taxo_fun(dada_res = dada_res, id_db = c("path_to_your_banks/silva/SILVA_SSU_r132_March2018.RData","path_to_your_banks/DAIRYdb_v1.2.0_20190222_IDTAXA.RData") )
```

```{r echo=FALSE}
DT::datatable(tax_table(data), filter = "top", options = list(scrollX = TRUE))
```


Main file outputs:

- `./idtaxa/robjects.Rdata` with taxonomy in phyloseq format in `tax.table` object.

- `final_tax_table.csv` the final assignation table that will be use in next steps.

- `allDB_tax_table.csv` raw assignations from the two databases, mainly for debugging.

## Phylogenetic Tree

The phylogenetic tree from the representative sequences is generated using phangorn and DECIPHER packages.

```{r eval=FALSE}
tree = generate_tree_fun(dada_res)
```

Main outputs:
- `tree_robjects.Rdata` with phylogenetic `tree` object in phyloseq format.

## Phyloseq object

To create a [phyloseq](https://joey711.github.io/phyloseq/) object, we need to merge four objects and one file:

- the asv table `dada_res` and  the representative sequences `seqtab.nochim` from `dada2_robjects.Rdata`

- a taxonomy table (`taxtable`) `taxo_robjects.Rdata` from `taxo_robjects.Rdata`

- the phylogenetic tree `tree` from `tree_robjects.Rdata`

- `metadata` from `sample-metadata.csv`

```{r eval = FALSE}
data = generate_phyloseq_fun(dada_res = dada_res, tax.table = tax.table, tree = tree, metadata = "./sample_metadata.csv")
```

```{r}
data
```


Main output:

* `./phyloseq/robjects.Rdata` with phyloseq object in `data` for raw counts and `data_rel` for relative abundance.

## Decontamination

The `decontam_fun` function uses [decontam](https://www.bioconductor.org/packages/release/bioc/html/decontam.html) R package with control samples to filter contaminants.
The decontam package offers two main methods, frequency and prevalence (and then you can combine those methods). For frequency method, it is mandatory to have the dna concentration of each sample in phyloseq (and hence in the `sample-metadata.csv`).
"_In this method, the distribution of the frequency of each sequence feature as a function of the input DNA concentration is used to identify contaminants._"
In the prevalence methods no need of DNA quantification.
"_In this method, the prevalence (presence/absence across samples) of each sequence feature in true positive samples is compared to the prevalence in negative controls to identify contaminants._"

Tips: sequencing plateforms often quantify the DNA before sequencing, but do not automaticaly give the information. Just ask for it ;).

Our function integrates the basics ASV frequency (nb_reads_ASV/nb_total_reads) and prevalence (nb_sample_ASV/nb_total_sample) filtering.
As in our lab we had a known recurrent contaminant we included an option to filter out ASV based on they taxa names.

```{r eval=FALSE}
data = decontam_fun(data = data, domain = "Bacteria", column = "type", ctrl_identifier = "control", spl_identifier = "sample", number = 100, krona= TRUE)
```

Main outputs:
- `robjects.Rdata` with contaminant filtered phyloseq object named `data`.
- `Exclu_out.csv`  list of filtered ASVs for each filtering step.
- Kronas [before](test/krona_no_filtering.html) and [after](test/krona_filtering.html) filtering.
- `raw_asv-table.csv` & `relative_asv-table.csv`.
- `venndiag_filtering.png`.

![venndiag](./decontam_out/venndiag_filtering.png)

# Plots, diversity and statistics

!!! We are currently developping a ShinyApp to visualize your data, sub-select your samples/taxons and do all those analyses interactively !!!
[ExploreMetabar](https://forgemia.inra.fr/umrf/exploremetabar)

## Rarefaction curves

In order to observe the sampling depth of each samples we start by plotting rarefactions curves. Those plots are generated by Plotly which makes the plots interactive.

```{r rareproc, warning = FALSE, results='hide'}
rareplot = rarefaction(data, "strain_time", 100 )
```
```{r rareplot}
htmltools::tagList(list(rareplot))
```

## Composition plots


The `bar_fun` function outputs a composition plot, in this example it reveals the top 10 genus present in our samples, but it is possible to plot at different `rank` and to modify the number of taxas to show.

- `Ord1` option order the sample along the X axis.

- `Fact1` option control labels of the X axis. `Fact1="sample.id"` if you don't want the sample to be renamed.

### Raw abundance
```{r compo_raw, fig.width=10, warning=FALSE, message=FALSE}
bars_fun(data = data, top = 10, Ord1 = "strain_time", Fact1 = "strain_time", rank="Genus", relative = FALSE)
```

### Relative abundance
```{r compo_relative, fig.width=10, message=FALSE, warning=FALSE}
bars_fun(data = data, top = 10, Ord1 = "strain_time", Fact1 = "strain_time", rank="Genus", relative = TRUE)
```


## Diversity analyses

### Alpha diversity

This function computes various alpha diversity indexes, it uses the [`estimate_richness`](https://www.rdocumentation.org/packages/phyloseq/versions/1.16.2/topics/estimate_richness) function from Phyloseq.

Available measures : c("Observed", "Chao1", "ACE", "Shannon", "Simpson", "InvSimpson", "Fisher").

It returns a list which contains:

- a boxplot comparing conditions. (`$plot`)

- a table of indices values.  (`$alphatable`)

And for each of the computed indices :

- an ANOVA analysis. (`${measure}$anova`)

- a wilcox result test comparing conditions and giving the significativity of the observed differences. (`${measure}$wilcox_col1`, `${measure}$wilcox_col2_fdr`, `${measure}$wilcox_col2_collapsed`)

- a mixture model if your data include repetition in sampling, ie. `column3` option. (`${measure}$anovarepeat`, `${measure}$mixedeffect`)


All this in a single function.

```{r alpha, warning=FALSE, message=FALSE, results = 'hide'}
alpha <- diversity_alpha_fun(data = data, output = "./plot_div_alpha/", column1 = "strain", column2 = "time", column3 = "", supcovs = "", measures = c("Observed", "Shannon") )
```

### Table of diversity index values
The table of values for each indices you choose to compute.
```{r alpha_tables}
pander(alpha$alphatable, style='rmarkdown')
```
### Boxplots

The boxplots of those values.

```{r alpha_boxplots, warnings = FALSE, message=FALSE, echo = TRUE}
ggplotly(alpha$plot) %>%
  layout(boxmode = "group")
```

### Tests on Observed index

#### ANOVA results

For each indices, you have access to the ANOVA test. Here we present the result for the "Observed" indice.

```{r}
pander(alpha$Observed$anova)
```

#### Wilcox test

Wilcox tests are made on each factor you have entered, and the combination of the two. Here "strain" and "time".

#### Wilcox test for "strain" factor
```{r}
pander(alpha$Observed$wilcox_col1)
```
#### Wilcox test for "time" factor FDR corrected.
```{r}
pander(alpha$Observed$wilcox_col2_fdr)
```
#### Wilcox test for the collapsed factors
```{r}
pander(alpha$Observed$wilcox_col2_collapsed)
```


## Beta diversity

The `diversity_beta_fun` function is an exhaustive function allowing to generate all possible tests and ordination in one command.


The `diversity_beta_light` function is equivalent to the first fonction but allows to generate specific tests and figures ready to publish in rmarkdown as in the example below. It is bases on the vegan package function [`vegdist`](https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/vegdist) for the distance calculation and [`ordinate`](https://www.rdocumentation.org/packages/phyloseq/versions/1.16.2/topics/ordinate) for the ordination plot.

We include statiscal test to ease the interpretation of your results. Here we include permutational ANOVA to compare groups and test that the centroids and dispersion of the groups are equivalent for all groups. User can inform `col` and `cov` arguments to assess PERMANOVA to determine significant differences between groups (eg. factor "strain" here and covariable "time"). A pairwise-PERMANOVA is processed to determine which conditions are significantly different from another (based on p-value).

As return, you will get an object that contains:

- An ordination plot (`$plot`)

- The permANOVA results (`$permanova`)

- The pairwise permANOVA (`$pairwisepermanova`)

```{r beta, warning=FALSE, results = 'hide'}
# beta <- diversity_beta_light(data = data, output = "./plot_div_beta/", glom = "ASV", column1 = "time", column2 = "strain", covar ="")
beta_strain = diversity_beta_light(data, col = "strain", cov="time", dist0 = "bray", ord0 = "MDS", output="./plot_div_beta_strain/", tests = TRUE)
beta_time = diversity_beta_light(data, col = "time", cov="strain", dist0 = "bray", ord0 = "MDS", output="./plot_div_beta_time/", tests = TRUE)

beta_strain_time = diversity_beta_light(data, col = "strain_time", dist0 = "bray", ord0 = "MDS", output="./plot_div_beta_strain_time/", tests = TRUE)
```
### Ordination plot


```{r beta_ordination, warning=FALSE}
htmltools::tagList(list(ggplotly(beta_strain$plot), ggplotly(beta_time$plot), ggplotly(beta_strain_time$plot)))
```


### Statistical tests

* permanova

```{r beta_test1, warning=FALSE}
pander(beta_strain$permanova)
```

* pairwise permanova on concatenated factors

```{r beta_test2, warning=FALSE}
pander(beta_strain_time$pairwisepermanova)
```



## Differential analyses

We choose three different methods to process differential analysis which is a key step of the workflow. The main advantage of the use of multiple methods is the cross validation of differentially abundant taxa between tested conditions.

### Metacoder

Metacoder is the most simple differential analysis tool of the three. Counts are normalized by total sum scaling to minimise the sample sequencing depth effect and metacoder use a Kruskal-Wallis test to determine significant difference between sample groups. The `metacoder_fun` function allows the user to choose the **taxonomic `rank`**, which factor to the test (`column1`), and a specific pairwise comparison (`comp`) to launch the differential analysis.

It also produces pretty graphical trees, representing the taxa present in both groups and coloring the branches depending on the group in which this taxa is more abundant. Two of those trees are produced, the raw one and the filtered one (p-value <= 0.05).

```{r,warning = FALSE, message = FALSE,  fig.keep='all', fig.align='left', fig.width = 15, fig.height = 10, echo = TRUE, results = 'hide'}
out1 = metacoder_fun(data = data, output = "./metacoder", column1 = "strain_time", rank = "Family", signif = TRUE, plottrees = TRUE, min ="10", comp = "wildtype_t50~mutant_t50,wildtype_t0~mutant_t0")

```

- Table
```{r,warning = FALSE, message = TRUE,  fig.keep='all', fig.align='left', fig.width = 15, fig.height = 10, echo = TRUE}
 DT::datatable(out1$table, filter = "top", options = list(scrollX = TRUE))
```

- Comparaison 1
```{r,warning = FALSE, message = TRUE,  fig.keep='all', fig.align='left', fig.width = 15, fig.height = 10, echo = TRUE}
 out1$wildtype_t0_vs_mutant_t0$signif
```

- Comparaison 2
```{r,warning = FALSE, message = TRUE,  fig.keep='all', fig.align='left', fig.width = 15, fig.height = 10, echo = TRUE}
 out1$wildtype_t50_vs_mutant_t50$signif
```



### DESeq2

DESeq2 is a widely used method, primarily for RNAseq applications, for assessing differentially expressed genes between controlled conditions. Its use for metabarcoding datas is sensibly the same. The `deseq2_fun` allows to process differential analysis as `metacoder_fun`, and users can choose the taxonomic rank, factor to test and which conditions to compare. DESeq2 algorithm uses negative binomial generalized linear models with VST normalization (Varian Stabilizing Transformation).

```{r,warning = FALSE, message = FALSE, echo = TRUE, fig.width = 15, results = 'hide'}
#fig.keep='all', fig.align='left', fig.width = 15, fig.height = 10
out2 = deseq2_fun(data = data, output = "./deseq/", column1 = "strain_time", verbose = 1, rank = "Family", comp = "wildtype_t50~mutant_t50,wildtype_t0~mutant_t0")
```

```{r,warning = FALSE, message = FALSE, echo = TRUE, fig.width = 10}
ggplotly(out2$wildtype_t50_vs_mutant_t50$plot)
DT::datatable(out2$wildtype_t50_vs_mutant_t50$table, filter = "top", options = list(scrollX = TRUE))
```

### MetagenomeSeq


MetagenomeSeq use a normalization method able to control for biases in measurements across taxonomics features and a mixture model taht implements a zero-inflated Gaussian distribution to account for varying depths of coverage.


```{r,warning = FALSE, message = TRUE,  fig.keep='all', fig.align='left', echo = TRUE, results = "hide"}
out3 = metagenomeseq_fun(data = data, output = "./metagenomeseq/", column1 = "strain_time", verbose = 1, rank = "Family", comp = "wildtype_t50~mutant_t50,wildtype_t0~mutant_t0")
```

```{r,warning = FALSE, message = TRUE,  fig.keep='all', fig.align='left', echo = TRUE}
ggplotly(out3$wildtype_t50_vs_mutant_t50$plot)

DT::datatable(out3$wildtype_t50_vs_mutant_t50$table, filter = "top", options = list(scrollX = TRUE))
```

### Aggregate methods

The `aggregate_fun` function allows to merge the results from the three differential analysis methods used before, to obtain one unique table with all information of significant differentially abundant features.

The generated table include the following informations :

* seqid: ASV ID

* Comparaison: Tested comparison

* Deseq: differentially abundant with this method (0 no or 1 yes)

* metagenomeSeq: differentially abundant with this method (0 no or 1 yes)

* metacoder:differentialy abundant with this method (0 no or 1 yes)

* sumMethods: sum of methods in which feature in significant.

* DESeqLFC: Log Fold Change value from DESeq2

* absDESeqLFC: absolute value of Log Fold Change value from DESeq2

* MeanRelAbcond1: Mean relative abundance in condition 1

* MeanRelAbcond2: Mean relative abundance in condition 2

* Condition: in which the mean feature abundance is higher.

* Taxonomy & representative sequence.


```{r,warning = FALSE, message = TRUE,  fig.keep='all', fig.align='left', fig.height = 10, echo = TRUE, results = "hide"}
resF = aggregate_fun(data = data, metacoder = "./metacoder/metacoder_signif_Family.csv", deseq = "./deseq/", mgseq = "./metagenomeseq/", output = "./aggregate_diff/", column1 = "strain_time", column2 = NULL, verbose = 1, rank = "Genus", comp = "wildtype_t50~mutant_t50,wildtype_t0~mutant_t0")
```

```{r,warning = FALSE, message = TRUE,  fig.keep='all', fig.align='left'}
ggplotly(resF$wildtype_t0_vs_mutant_t0$plot)

ggplotly(resF$wildtype_t50_vs_mutant_t50$plot)

DT::datatable(resF$table, filter = "top", options = list(scrollX = TRUE))
```


### PLSDA (Partial Least Squares Discriminant Analysis)

Our PLS-DA/sparse PLS-DA analysis is based on the [mixOmics package](http://mixomics.org/methods/pls-da/). The `plsda_res` function outputs a list of graphs and tables:

- `plsda$plotIndiv` ordination plot from the PLSDA analysis.

- `splsda$plotIndiv` ordination plot from the sparse PLSDA analysis.

- `loadings$comp{n}` all the loadings plots for each composant from the sPLSDA analysis.

- `splsda$plotArrow` arrow plot of samples.

- `splda.loading_table` Loading of all taxas for each composant.

```{r pslda, results = 'hide', warning = FALSE, message = FALSE}
plsda_res <- plsda_fun(data = data, output = "./plsda_family/", column1 = "strain_time", rank = "Family")
```

```{r splsda.plotIndiv}
plsda_res$splsda.plotIndiv$graph
```


```{r plsda.loadings, fig.align='center', fig.show='hold'}
knitr::include_graphics('plsda_family/splsda_loadings_strain_time_Family_comp1.png')
```

```{r plsda.loadings2, fig.align='center', fig.show='hold'}
knitr::include_graphics('plsda_family/splsda_loadings_strain_time_Family_comp2.png')
```

```{r plsda.loadings3, fig.align='center', fig.show='hold'}
knitr::include_graphics('plsda_family/splsda_loadings_strain_time_Family_comp3.png')
```

```{r plsda.loadings4, fig.align='center', fig.show='hold'}
knitr::include_graphics('plsda_family/splsda_loadings_strain_time_Family_comp4.png')
```
# Miscellaneous function

## Heatmap

`heatmap_fun` allows to plot relative abundance of more abundant taxas (20 by default). Use can choose which taxonomy rank to plot and the factor used to seprate plot.

```{r heatmap, fig.align='center', results = "hide"}
heatmap_plot = heatmap_fun(data = data, column1 = "strain_time", top = 20, output = "./plot_heatmap/", rank = "Species")
```

```{r heatmapplot, fig.align='center'}
ggplotly(heatmap_plot)
```

## Shared taxa

* Venn Diagram

`ASVenn_fun` allows to define shared taxa between specific condtitions (up to 5 conditions). It generates Venn Diagram and table informing presence of each ASV in each condition with taxonomy and sequence. Counts can be verified with this table. `rank` argument allows to generate output with upper taxonomy level taxas.

```{r asvenn, results = "hide"}
outvenn = ASVenn_fun(data = data,output = "./ASVenn/", rank = "ASV", column1 = "strain_time", shared = TRUE)
```

* Venn diagram: 

```{r}
grid.draw(outvenn$venn_plot)
```

* Table:

```{r}
DT::datatable(outvenn$TABf, filter = "top", options = list(scrollX = TRUE))
```

* Cytoscape
`phy2cyto_fun` allows to generate input files for cytoscape which is usefull to vizualise shared taxa.




## Supplementary tools and features

`csv2phyloseq_fun` allows to import the 4 files in tabulated format to generate phyloseq object ready to use with `rANOMALY`.

`assign_fasta_fun` is used to assign sequences from fasta files.

`export_to_stamp_fun` allows you to generate input files for [STAMP](https://beikolab.cs.dal.ca/software/STAMP).

`split_table_fun` allows to split the phyloseq object in multiple sub-object according to one column.

`update_metadata_fun` allows you to easily modify `sample_data` part of the phyloseq object.
